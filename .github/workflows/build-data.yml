name: Build Data (Issues → data/normalized.json)

on:
  issues: { types: [opened, edited, closed, reopened] }
  workflow_dispatch:

permissions:
  contents: write   # data/* içine commit atabilsin

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build normalized.json (no deps)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // ---- Beyaz liste: sadece bu kullanıcıların issue'ları işlenir ----
            const ALLOWED = new Set(['metinciris']); // ← kendi adını bırak/ekle

            // yardımcılar
            const toInt = (x)=>{ const n = parseInt(String(x??'').trim(),10); return Number.isFinite(n)?n:NaN; }
            const pick = (body,labelPattern)=>{
              const re = new RegExp(`###\\s*(?:${labelPattern})\\s*\\n([\\s\\S]*?)(?=\\n###|$)`,'i');
              const m = (body||'').match(re); let v = m ? (m[1]||'').trim() : '';
              if (/^_?no response_?$/i.test(v)) v = ''; return v;
            };
            const parseSingleFromTitle = (title)=>{
              const m = /\[Meal\].*?S[ûu]re\s+(\d{1,3}).*?[ÂA]yet\s+(\d{1,3})/i.exec(title||'');
              return m ? { sure: toInt(m[1]), ayet: toInt(m[2]) } : null;
            };
            const parseSingleFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const ayet = toInt(pick(body,"[ÂA]yet\\s*No|Ayet\\s*No|[ÂA]yet|Ayet"));
              const meal = pick(body,"Meal(?:\\s*Metni)?|Meal");
              const aciklama = pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama");
              if (!Number.isFinite(sure)||!Number.isFinite(ayet)||!meal) return null;
              return { sure, ayet, meal, aciklama };
            };
            const parseBulkBlock = (blob)=>{
              const lines=(blob||'').replace(/\r/g,'').split('\n');
              const out=[]; let cur=null; const start=/^\s*(\d{1,3})\s*([\-–—.:])\s*(.*)$/;
              for (const raw of lines){
                const line=raw.trimEnd(); const m=start.exec(line);
                if (m){ const ayet=toInt(m[1]); const text=(m[3]||'').trim();
                  if (Number.isFinite(ayet)){ cur={ayet,meal:text}; out.push(cur);} else {cur=null;} }
                else if (cur){ const t=line.trim(); if (t) cur.meal=(cur.meal?cur.meal+'\n':'')+t; }
              }
              return out.filter(x=>x.meal && x.meal.trim());
            };
            const parseBulkFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const blob = pick(body,"Toplu\\s*Metin|Toplu\\s*Meal|Toplu|Metin");
              if (!Number.isFinite(sure)||!blob) return null;
              return parseBulkBlock(blob).map(x=>({sure, ayet:x.ayet, meal:x.meal, aciklama:''}));
            };

            // ---- last-write-wins ----
            const latest = new Map(); // "s:a" -> record
            let scanned=0, accepted=0;

            for (const state of ['open','closed']){
              let page=1;
              while(true){
                const resp = await github.rest.issues.listForRepo({
                  owner: context.repo.owner, repo: context.repo.repo,
                  state, per_page: 100, page
                });
                const items = resp.data || [];
                if (!items.length) break;

                for (const it of items){
                  if (it.pull_request) continue;
                  scanned++;
                  const author = it.user?.login || '';
                  if (!ALLOWED.has(author)) continue;

                  const title = it.title || '';
                  const body  = it.body  || '';

                  if (/^\s*\[BulkMeal\]/i.test(title)){
                    const pack = parseBulkFromBody(body); if (!pack) continue;
                    for (const r of pack){
                      const key = `${r.sure}:${r.ayet}`;
                      const rec = { sure:r.sure, ayet:r.ayet, meal:r.meal.trim(), aciklama:'', last: it.updated_at };
                      const prev = latest.get(key);
                      if (!prev || rec.last > prev.last) latest.set(key, rec);
                      accepted++;
                    }
                  } else if (/^\s*\[Meal\]/i.test(title)){
                    let p = parseSingleFromBody(body);
                    if (!p){
                      const ft = parseSingleFromTitle(title);
                      if (ft){
                        p = { ...ft,
                          meal: pick(body,"Meal(?:\\s*Metni)?|Meal"),
                          aciklama: pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama")
                        };
                      }
                    }
                    if (!p || !p.meal) continue;
                    const key = `${p.sure}:${p.ayet}`;
                    const rec = { sure:p.sure, ayet:p.ayet, meal:p.meal.trim(), aciklama:(p.aciklama||'').trim(), last: it.updated_at };
                    const prev = latest.get(key);
                    if (!prev || rec.last > prev.last) latest.set(key, rec);
                    accepted++;
                  }
                }
                page++;
              }
            }

            const rows = [...latest.values()].sort((a,b)=> a.sure - b.sure || a.ayet - b.ayet);
            const lastUpdated = rows.reduce((m,x)=> m && m>x.last ? m : x.last, null);

            require('fs').mkdirSync('data', { recursive:true });
            fs.writeFileSync('data/normalized.json', JSON.stringify({ rows, lastUpdated }, null, 2), 'utf8');

            core.info(`Scanned: ${scanned}, Accepted: ${accepted}, Rows: ${rows.length}`);
            core.info(`lastUpdated: ${lastUpdated || '-'}`);

      - name: Commit data/normalized.json
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "build: update data/normalized.json (last-write-wins)"
          file_pattern: data/normalized.json
