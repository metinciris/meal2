name: Build Data (Issues → data/*.json)

on:
  issues: { types: [opened, edited, closed, reopened] }
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build normalized.json & embeds.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // --- Sadece bu kullanıcıların açtığı issue'lar işlenir
            const ALLOWED = new Set(['metinciris']);

            // ---------- yardımcılar ----------
            const toInt = (x)=>{ const n = parseInt(String(x??'').trim(),10); return Number.isFinite(n) ? n : NaN; };
            const pick = (body,labelPattern)=>{
              const re = new RegExp(`###\\s*(?:${labelPattern})\\s*\\n([\\s\\S]*?)(?=\\n###|$)`,'i');
              const m = (body||'').match(re); let v = m ? (m[1]||'').trim() : '';
              if (/^_?no response_?$/i.test(v)) v=''; return v;
            };

            // ---------- Meal parser'ları ----------
            const parseMealFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const ayet = toInt(pick(body,"[ÂA]yet\\s*No|Ayet\\s*No|[ÂA]yet|Ayet"));
              const meal = pick(body,"Meal(?:\\s*Metni)?|Meal");
              const aciklama = pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama");
              if (!Number.isFinite(sure)||!Number.isFinite(ayet)||!meal) return null;
              return { sure, ayet, meal, aciklama };
            };
            const parseMealBulkBlock = (blob)=>{
              const lines=(blob||'').replace(/\r/g,'').split('\n');
              const out=[]; let cur=null; const rx=/^\s*(\d{1,3})\s*[:\-–—.]\s*(.*)$/;
              for (const raw of lines){
                const m = rx.exec(raw.trim());
                if (m){ const ayet=toInt(m[1]); const text=(m[2]||'').trim();
                  if (Number.isFinite(ayet) && text){ cur={ayet, meal:text}; out.push(cur); } }
                else if (cur && raw.trim()){ cur.meal += '\n'+raw.trim(); }
              }
              return out;
            };
            const parseMealBulkFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const blob = pick(body,"Toplu\\s*Metin|Toplu\\s*Meal|Toplu|Metin");
              if (!Number.isFinite(sure)||!blob) return null;
              return parseMealBulkBlock(blob).map(x=>({sure, ayet:x.ayet, meal:x.meal, aciklama:''}));
            };

            // ---------- YouTube yardımcıları ----------
            const hmsToSec = (hms)=>{
              if (!hms) return 0;
              if (/^\d+$/.test(hms)) return parseInt(hms,10);
              const m = String(hms).match(/(?:(\d+):)?(\d+):(\d+)/);
              if (m) return (+(m[1]||0))*3600 + (+m[2])*60 + (+m[3]);
              const t = String(hms).replace(/^t=/i,'');
              const mh = t.match(/(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?/i);
              if (mh) return (+(mh[1]||0))*3600 + (+(mh[2]||0))*60 + (+(mh[3]||0));
              return 0;
            };
            const parseYTFromBody = (body)=>{
              const sure  = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const after = toInt(pick(body,"Hangi\\s*[ÂA]yetten\\s*SONRA.*|after"));
              const url   = pick(body,"YouTube\\s*URL|URL|Url");
              const start = pick(body,"Ba[sş]lang[ıi]ç.*|start");
              const title = pick(body,"Ba[sş]l[ıi]k|baslik|title");
              if (!Number.isFinite(sure)||!Number.isFinite(after)||!url) return null;
              let startSec = 0;
              try{
                const u = new URL(url);
                if (u.searchParams.get('start')) startSec = parseInt(u.searchParams.get('start'),10)||0;
                if (u.searchParams.get('t'))     startSec = hmsToSec(u.searchParams.get('t')) || startSec;
              }catch(_){}
              if (start) startSec = hmsToSec(start);
              return { sure, after, url, start:startSec, title:(title||'').trim() };
            };
            const parseYTBlock = (blob, sure)=>{
              const lines=(blob||'').replace(/\r/g,'').split('\n'); const out=[];
              for (const raw of lines){
                const line=raw.trim(); if (!line) continue;
                const [a,u,s,t] = line.split('|').map(x=>(x||'').trim());
                const after=toInt(a); const url=u;
                if (!Number.isFinite(after)||!url) continue;
                let startSec = 0;
                try{
                  const uu = new URL(url);
                  if (uu.searchParams.get('start')) startSec = parseInt(uu.searchParams.get('start'),10)||0;
                  if (uu.searchParams.get('t'))     startSec = hmsToSec(uu.searchParams.get('t')) || startSec;
                }catch(_){}
                if (s) startSec = hmsToSec(s);
                out.push({ sure, after, url, start:startSec, title:t||'' });
              }
              return out;
            };

            // ---------- last-write-wins depolar ----------
            const mealLatest  = new Map(); // "sure:ayet" -> {sure,ayet,meal,aciklama,last}
            const embedLatest = new Map(); // "sure:after:url" -> {sure,after,url,start,title,last}

            let scanned=0, accepted=0, ytAccepted=0;

            for (const state of ['open','closed']){
              let page=1;
              while(true){
                const resp = await github.rest.issues.listForRepo({
                  owner: context.repo.owner, repo: context.repo.repo,
                  state, per_page: 100, page
                });
                const items = resp.data || [];
                if (!items.length) break;

                for (const it of items){
                  if (it.pull_request) continue;
                  scanned++;
                  const author = it.user?.login || '';
                  if (!ALLOWED.has(author)) continue;

                  const title = it.title || '';
                  const body  = it.body  || '';

                  // --- MEAL bulk
                  if (/^\s*\[BulkMeal\]/i.test(title)){
                    const pack = parseMealBulkFromBody(body); if (!pack) continue;
                    for (const r of pack){
                      const key = `${r.sure}:${r.ayet}`;
                      const rec = { ...r, last: it.updated_at };
                      const prev = mealLatest.get(key);
                      if (!prev || rec.last > prev.last) mealLatest.set(key, rec);
                      accepted++;
                    }
                    continue;
                  }

                  // --- MEAL tekli
                  if (/^\s*\[Meal\]/i.test(title)){
                    const p = parseMealFromBody(body);
                    if (p && p.meal){
                      const key = `${p.sure}:${p.ayet}`;
                      const rec = { ...p, last: it.updated_at };
                      const prev = mealLatest.get(key);
                      if (!prev || rec.last > prev.last) mealLatest.set(key, rec);
                      accepted++;
                    }
                    continue;
                  }

                  // --- YOUTUBE bulk
                  if (/^\s*\[(BulkYT|BulkYouTube)\]/i.test(title)){
                    const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
                    const blob = pick(body,"Sat[ıi]r\\s*sat[ıi]r\\s*veri|blob");
                    if (Number.isFinite(sure) && blob){
                      for (const r of parseYTBlock(blob, sure)){
                        const key = `${r.sure}:${r.after}:${r.url}`;
                        const rec = { ...r, last: it.updated_at };
                        const prev = embedLatest.get(key);
                        if (!prev || rec.last > prev.last) embedLatest.set(key, rec);
                        ytAccepted++;
                      }
                    }
                    continue;
                  }

                  // --- YOUTUBE tekli
                  if (/^\s*\[(YT|YouTube)\]/i.test(title)){
                    const r = parseYTFromBody(body);
                    if (r){
                      const key = `${r.sure}:${r.after}:${r.url}`;
                      const rec = { ...r, last: it.updated_at };
                      const prev = embedLatest.get(key);
                      if (!prev || rec.last > prev.last) embedLatest.set(key, rec);
                      ytAccepted++;
                    }
                    continue;
                  }
                }
                page++;
              }
            }

            // ---------- normalized.json yaz ----------
            const mealRows = [...mealLatest.values()]
              .sort((a,b)=> a.sure - b.sure || a.ayet - b.ayet)
              .map(r => ({ sure:r.sure, ayet:r.ayet, meal:r.meal.trim(), aciklama:(r.aciklama||'').trim(), last:r.last }));
            const lastUpdated = mealRows.reduce((m,x)=> m && m>x.last ? m : x.last, null);

            fs.mkdirSync('data', { recursive:true });
            fs.writeFileSync('data/normalized.json', JSON.stringify({ rows: mealRows, lastUpdated }, null, 2), 'utf8');

            // ---------- embeds.json yaz ----------
            const embedsRows = [...embedLatest.values()]
              .sort((a,b)=> a.sure - b.sure || a.after - b.after || String(a.title||'').localeCompare(String(b.title||'')));
            const lastYTUpdated = embedsRows.reduce((m,x)=> m && m>x.last ? m : x.last, null);

            const bySurah = {};
            for (const r of embedsRows){
              const k = String(r.sure);
              (bySurah[k] ||= []).push({ after:r.after, url:r.url, start:r.start||0, title:r.title||'' });
            }
            fs.writeFileSync('data/embeds.json', JSON.stringify({ bySurah, lastUpdated:lastYTUpdated }, null, 2), 'utf8');

            core.info(`Scanned:${scanned} MealAccepted:${accepted} YTAccepted:${ytAccepted}`);
            core.info(`MealRows:${mealRows.length} YTRows:${embedsRows.length}`);
            core.info(`lastUpdated:${lastUpdated||'-'} lastYTUpdated:${lastYTUpdated||'-'}`);

      - name: Commit data files
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "build: update data (normalized & embeds)"
          file_pattern: |
            data/normalized.json
            data/embeds.json
