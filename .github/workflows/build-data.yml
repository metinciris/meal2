name: Build Data (Issues → data/*)

on:
  issues: { types: [opened, edited, closed, reopened] }
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build all data files (no deps)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // ---- BEYAZ LİSTE: sadece bunların issue'ları işlenir ----
            const ALLOWED = new Set([
              'metinciris', // ← Kendi kullanıcı adın burada OLMALI
            ]);

            // ---- Yardımcılar ----
            const AYAHS = [0,7,286,200,176,120,165,206,75,129,109,123,111,43,52,99,128,111,110,98,135,
              112,78,118,64,77,227,93,88,69,60,34,30,73,54,45,83,182,88,75,85,54,53,89,59,37,35,38,29,18,45,
              60,49,62,55,78,96,29,22,24,13,14,11,11,18,12,12,30,52,52,44,28,28,20,56,40,31,50,40,46,42,29,19,
              36,25,22,17,19,26,30,20,15,21,11,8,8,19,5,8,8,11,11,8,3,9,5,4,7,3,6,3,5,4,5,6];

            const toInt = (x)=>{ const n = parseInt(String(x??'').trim(),10); return Number.isFinite(n)?n:NaN; };
            const pick = (body,labelPattern)=>{
              // Issue Forms "### Etiket" başlıklarını yakalar
              const re = new RegExp(`###\\s*(?:${labelPattern})\\s*\\n([\\s\\S]*?)(?=\\n###|$)`,'i');
              const m = (body||'').match(re); let v = m ? (m[1]||'').trim() : '';
              if (/^_?no response_?$/i.test(v)) v = '';
              return v;
            };
            const parseSingleFromTitle = (title)=>{
              // Başlık: [Meal] Sûre 1 : Âyet 2
              const m = /\[Meal\].*?S[ûu]re\s+(\d{1,3}).*?[ÂA]yet\s+(\d{1,3})/i.exec(title||'');
              return m ? { sure: toInt(m[1]), ayet: toInt(m[2]) } : null;
            };
            const parseSingleFromBody = (body)=>{
              // Şu etiketlerden biri olsun: "Sûre (1-114)" veya "Sure (1-114)"
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const ayet = toInt(pick(body,"[ÂA]yet\\s*No|Ayet\\s*No|[ÂA]yet|Ayet"));
              // Meal alan adları: "Meal Metni" ya da "Meal"
              const meal = pick(body,"Meal(?:\\s*Metni)?|Meal");
              const aciklama = pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama");
              if (!Number.isFinite(sure)||!Number.isFinite(ayet)||!meal) return null;
              return { sure, ayet, meal, aciklama };
            };
            const parseBulkBlock = (blob)=>{
              const lines=(blob||'').replace(/\r/g,'').split('\n');
              const out=[]; let cur=null; const start=/^\s*(\d{1,3})\s*([\-–—.:])\s*(.*)$/;
              for (const raw of lines){
                const line=raw.trimEnd(); const m=start.exec(line);
                if (m){ const ayet=toInt(m[1]); const text=(m[3]||'').trim();
                  if (Number.isFinite(ayet)){ cur={ayet,meal:text}; out.push(cur);} else {cur=null;} }
                else if (cur){ const t=line.trim(); if (t) cur.meal=(cur.meal?cur.meal+'\n':'')+t; }
              }
              return out.filter(x=>x.meal && x.meal.trim());
            };
            const parseBulkFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const blob = pick(body,"Toplu\\s*Metin|Toplu\\s*Meal|Toplu|Metin");
              if (!Number.isFinite(sure)||!blob) return null;
              return parseBulkBlock(blob).map(x=>({sure, ayet:x.ayet, meal:x.meal, aciklama:''}));
            };

            // ---- Issues tarama: last-write-wins ----
            const latest = new Map(); // "s:a" -> record
            let scanned=0, accepted=0;

            for (const state of ['open','closed']){
              let page=1;
              while(true){
                const resp = await github.rest.issues.listForRepo({
                  owner: context.repo.owner, repo: context.repo.repo,
                  state, per_page: 100, page
                });
                const items = resp.data || [];
                if (!items.length) break;

                for (const it of items){
                  if (it.pull_request) continue;
                  scanned++;

                  const author = it.user?.login || '';
                  if (!ALLOWED.has(author)) continue;

                  const title = it.title || '';
                  const body  = it.body  || '';

                  if (/^\s*\[BulkMeal\]/i.test(title)){
                    const pack = parseBulkFromBody(body);
                    if (!pack) continue;
                    for (const r of pack){
                      const key = `${r.sure}:${r.ayet}`;
                      const rec = { sure:r.sure, ayet:r.ayet, meal:r.meal.trim(), aciklama:'', last: it.updated_at };
                      const prev = latest.get(key);
                      if (!prev || rec.last > prev.last) latest.set(key, rec);
                      accepted++;
                    }
                  } else if (/^\s*\[Meal\]/i.test(title)){
                    let p = parseSingleFromBody(body);
                    if (!p){
                      const ft = parseSingleFromTitle(title);
                      if (ft){
                        p = { ...ft, meal: pick(body,"Meal(?:\\s*Metni)?|Meal"),
                                   aciklama: pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama") };
                      }
                    }
                    if (!p || !p.meal) continue;
                    const key = `${p.sure}:${p.ayet}`;
                    const rec = { sure:p.sure, ayet:p.ayet, meal:p.meal.trim(), aciklama:(p.aciklama||'').trim(), last: it.updated_at };
                    const prev = latest.get(key);
                    if (!prev || rec.last > prev.last) latest.set(key, rec);
                    accepted++;
                  }
                }
                page++;
              }
            }

            const rows = [...latest.values()].sort((a,b)=> a.sure - b.sure || a.ayet - b.ayet);
            const lastUpdated = rows.reduce((m,x)=> m && m>x.last ? m : x.last, null);

            // ---- Yaz ----
            const dataDir = path.join(process.cwd(),'data');
            const surahDir = path.join(dataDir,'surah');
            fs.mkdirSync(surahDir, { recursive:true });
            fs.writeFileSync(path.join(dataDir,'normalized.json'),
              JSON.stringify({ rows, lastUpdated }, null, 2), 'utf8');

            // per-sûre + manifest
            const bySurah = new Map();
            for (const r of rows){
              if (!bySurah.has(r.sure)) bySurah.set(r.sure, []);
              bySurah.get(r.sure).push(r);
            }
            for (let s=1; s<=114; s++){
              const list = (bySurah.get(s) || []).sort((a,b)=>a.ayet-b.ayet);
              fs.writeFileSync(path.join(surahDir, `${s}.json`),
                JSON.stringify({ sure: s, rows: list, lastUpdated }, null, 2), 'utf8');
              core.info(`Surah ${s} → ${list.length} ayet`);
            }

            const progress = [];
            for (let s=1; s<=114; s++){
              const done = (bySurah.get(s) || []).length;
              progress.push({ s, done, total: AYAHS[s] });
            }
            fs.writeFileSync(path.join(dataDir,'manifest.json'),
              JSON.stringify({ lastUpdated, progress }, null, 2), 'utf8');

            core.info(`Scanned: ${scanned}, Accepted: ${accepted}, Rows: ${rows.length}`);
            core.info(`lastUpdated: ${lastUpdated || '-'}`);

      - name: Commit data/**
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "build: update data (normalized + manifest + per-sûre)"
          file_pattern: |
            data/normalized.json
            data/manifest.json
            data/surah/**
