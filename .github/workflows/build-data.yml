name: Build Data (Issues → data/normalized.json)

on:
  issues: { types: [opened, edited, closed, reopened] }
  workflow_dispatch:

permissions:
  contents: write   # data/* içine commit atabilsin

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build normalized.json & embeds.json (no deps)  # >>> ADDED: başlık genişletildi
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // ---- Beyaz liste: sadece bu kullanıcıların issue'ları işlenir ----
            const ALLOWED = new Set(['metinciris']); // ← kendi adını bırak/ekle

            // -------------------------
            // Yardımcılar (mevcut + YouTube için ekler)
            // -------------------------
            const toInt = (x)=>{ const n = parseInt(String(x??'').trim(),10); return Number.isFinite(n)?n:NaN; }
            const pick = (body,labelPattern)=>{
              const re = new RegExp(`###\\s*(?:${labelPattern})\\s*\\n([\\s\\S]*?)(?=\\n###|$)`,'i');
              const m = (body||'').match(re); let v = m ? (m[1]||'').trim() : '';
              if (/^_?no response_?$/i.test(v)) v = ''; return v;
            };

            // (Meal tekli/bulk) mevcut parser'ların
            const parseSingleFromTitle = (title)=>{
              const m = /\[Meal\].*?S[ûu]re\s+(\d{1,3}).*?[ÂA]yet\s+(\d{1,3})/i.exec(title||'');
              return m ? { sure: toInt(m[1]), ayet: toInt(m[2]) } : null;
            };
            const parseSingleFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const ayet = toInt(pick(body,"[ÂA]yet\\s*No|Ayet\\s*No|[ÂA]yet|Ayet"));
              const meal = pick(body,"Meal(?:\\s*Metni)?|Meal");
              const aciklama = pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama");
              if (!Number.isFinite(sure)||!Number.isFinite(ayet)||!meal) return null;
              return { sure, ayet, meal, aciklama };
            };
            const parseBulkBlock = (blob)=>{
              const lines=(blob||'').replace(/\r/g,'').split('\n');
              const out=[]; let cur=null; const start=/^\s*(\d{1,3})\s*([\-–—.:])s*(.*)$/; // küçük düzeltme: kaçış
              const start2=/^\s*(\d{1,3})\s*([\-–—.:])\s*(.*)$/; // >>> ADDED (regex fix)
              for (const raw of lines){
                const line=raw.trimEnd();
                const m=start2.exec(line);
                if (m){ const ayet=toInt(m[1]); const text=(m[3]||'').trim();
                  if (Number.isFinite(ayet)){ cur={ayet,meal:text}; out.push(cur);} else {cur=null;} }
                else if (cur){ const t=line.trim(); if (t) cur.meal=(cur.meal?cur.meal+'\n':'')+t; }
              }
              return out.filter(x=>x.meal && x.meal.trim());
            };
            const parseBulkFromBody = (body)=>{
              const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const blob = pick(body,"Toplu\\s*Metin|Toplu\\s*Meal|Toplu|Metin");
              if (!Number.isFinite(sure)||!blob) return null;
              return parseBulkBlock(blob).map(x=>({sure, ayet:x.ayet, meal:x.meal, aciklama:''}));
            };

            // -------------------------
            // >>> ADDED: YouTube yardımcıları
            // -------------------------
            const hmsToSec = (hms)=>{
              if (!hms) return 0;
              if (/^\d+$/.test(hms)) return parseInt(hms,10);
              const m = String(hms).match(/(?:(\d+):)?(\d+):(\d+)/); // hh:mm:ss | mm:ss
              if (m){ const hh=parseInt(m[1]||0), mm=parseInt(m[2]||0), ss=parseInt(m[3]||0); return hh*3600+mm*60+ss; }
              const t = String(hms).replace(/^t=/i,'');
              const mh = t.match(/(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?/i);
              if (mh) return (parseInt(mh[1]||0)*3600)+(parseInt(mh[2]||0)*60)+(parseInt(mh[3]||0));
              return 0;
            };
            const parseYouTubeUrl = (url)=>{
              try{
                const u = new URL(url);
                let id = '';
                if (u.hostname.includes('youtu.be')) id = u.pathname.slice(1);
                else if (u.searchParams.get('v')) id = u.searchParams.get('v');
                else { const m = u.pathname.match(/\/embed\/([^/?#]+)/); if (m) id = m[1]; }
                let start = 0;
                if (u.searchParams.get('start')) start = parseInt(u.searchParams.get('start'),10)||0;
                if (u.searchParams.get('t'))     start = hmsToSec(u.searchParams.get('t')) || start;
                return { id, startFromUrl:start };
              }catch(e){ return { id:'', startFromUrl:0 }; }
            };
            const parseYTFromBody = (body)=>{
              const sure  = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
              const after = toInt(pick(body,"Hangi\\s*[ÂA]yetten\\s*SONRA.*|after"));
              const url   = pick(body,"YouTube\\s*URL|URL|Url");
              const start = pick(body,"Ba[sş]lang[ıi]ç.*|start");
              const title = pick(body,"Ba[sş]l[ıi]k|baslik|title");
              if (!Number.isFinite(sure) || !Number.isFinite(after) || !url) return null;
              const { id, startFromUrl } = parseYouTubeUrl(url);
              const startSec = start ? hmsToSec(start) : startFromUrl;
              return { sure, after, url, start: startSec, title: (title||'').trim() };
            };
            const parseYTBlock = (blob, sure)=>{
              const lines=(blob||'').replace(/\r/g,'').split('\n');
              const out=[];
              for (const raw of lines){
                const line = raw.trim();
                if (!line) continue;
                const parts = line.split('|').map(x=>x.trim());
                const after = toInt(parts[0]);
                const url   = parts[1] || '';
                const start = parts[2] || '';
                const title = parts[3] || '';
                if (!Number.isFinite(after) || !url) continue;
                const { id, startFromUrl } = parseYouTubeUrl(url);
                const startSec = start ? hmsToSec(start) : startFromUrl;
                out.push({ sure, after, url, start: startSec, title });
              }
              return out;
            };

            // ---- last-write-wins yapıları ----
            const latest = new Map();          // "s:a" -> meal record
            const embedLatest = new Map();     // >>> ADDED: "sure:after:url" -> embed record

            let scanned=0, accepted=0, ytAccepted=0; // >>> ADDED

            // -------------------------
            // Issue tarama (open + closed)
            // -------------------------
            for (const state of ['open','closed']){
              let page=1;
              while(true){
                const resp = await github.rest.issues.listForRepo({
                  owner: context.repo.owner, repo: context.repo.repo,
                  state, per_page: 100, page
                });
                const items = resp.data || [];
                if (!items.length) break;

                for (const it of items){
                  if (it.pull_request) continue;
                  scanned++;
                  const author = it.user?.login || '';
                  if (!ALLOWED.has(author)) continue;

                  const title = it.title || '';
                  const body  = it.body  || '';

                  // ---- MEAL: bulk
                  if (/^\s*\[BulkMeal\]/i.test(title)){
                    const pack = parseBulkFromBody(body); if (!pack) continue;
                    for (const r of pack){
                      const key = `${r.sure}:${r.ayet}`;
                      const rec = { sure:r.sure, ayet:r.ayet, meal:r.meal.trim(), aciklama:'', last: it.updated_at };
                      const prev = latest.get(key);
                      if (!prev || rec.last > prev.last) latest.set(key, rec);
                      accepted++;
                    }
                    continue;
                  }

                  // ---- MEAL: tekli
                  if (/^\s*\[Meal\]/i.test(title)){
                    let p = parseSingleFromBody(body);
                    if (!p){
                      const ft = parseSingleFromTitle(title);
                      if (ft){
                        p = { ...ft,
                          meal: pick(body,"Meal(?:\\s*Metni)?|Meal"),
                          aciklama: pick(body,"Aç(?:ı|i)klama(?:\\s*\\(opsiyonel\\))?|Acilklama|Aciklama")
                        };
                      }
                    }
                    if (p && p.meal){
                      const key = `${p.sure}:${p.ayet}`;
                      const rec = { sure:p.sure, ayet:p.ayet, meal:p.meal.trim(), aciklama:(p.aciklama||'').trim(), last: it.updated_at };
                      const prev = latest.get(key);
                      if (!prev || rec.last > prev.last) latest.set(key, rec);
                      accepted++;
                    }
                    // düşmeye devam etme; diğer bloklara bakılmasın
                    continue;
                  }

                  // -------------------------
                  // >>> ADDED: YOUTUBE blokları
                  // -------------------------
                  // Toplu YouTube: [BulkYouTube] / [BulkYT]
                  if (/^\s*\[(BulkYT|BulkYouTube)\]/i.test(title)){
                    const sure = toInt(pick(body,"S[ûu]re\\s*\\(1-114\\)|Sure\\s*\\(1-114\\)|S[ûu]re|Sure"));
                    const blob = pick(body,"Sat[ıi]r\\s*sat[ıi]r\\s*veri|blob");
                    if (Number.isFinite(sure) && blob){
                      const pack = parseYTBlock(blob, sure);
                      for (const r of pack){
                        const key = `${r.sure}:${r.after}:${r.url}`;
                        const rec = { ...r, last: it.updated_at };
                        const prev = embedLatest.get(key);
                        if (!prev || rec.last > prev.last) embedLatest.set(key, rec);
                        ytAccepted++;
                      }
                    }
                    continue;
                  }

                  // Tekli YouTube: [YouTube] / [YT]
                  if (/^\s*\[(YT|YouTube)\]/i.test(title)){
                    const r = parseYTFromBody(body);
                    if (r){
                      const key = `${r.sure}:${r.after}:${r.url}`;
                      const rec = { ...r, last: it.updated_at };
                      const prev = embedLatest.get(key);
                      if (!prev || rec.last > prev.last) embedLatest.set(key, rec);
                      ytAccepted++;
                    }
                    continue;
                  }
                }
                page++;
              }
            }

            // -------------------------
            // Yazımlar
            // -------------------------

            // 1) normalized.json (mevcut)
            const rows = [...latest.values()].sort((a,b)=> a.sure - b.sure || a.ayet - b.ayet);
            const lastUpdated = rows.reduce((m,x)=> m && m>x.last ? m : x.last, null);

            require('fs').mkdirSync('data', { recursive:true });
            fs.writeFileSync('data/normalized.json', JSON.stringify({ rows, lastUpdated }, null, 2), 'utf8');

            // 2) >>> ADDED: embeds.json (YouTube)
            const embedsRows = [...embedLatest.values()]
              .sort((a,b)=> a.sure - b.sure || a.after - b.after || String(a.title||'').localeCompare(String(b.title||'')));
            const lastYTUpdated = embedsRows.reduce((m,x)=> m && m>x.last ? m : x.last, null);

            const bySurah = {};
            for (const r of embedsRows){
              const k = String(r.sure);
              (bySurah[k] ||= []).push({ after:r.after, url:r.url, start:r.start||0, title:r.title||'' });
            }
            fs.writeFileSync('data/embeds.json', JSON.stringify({ bySurah, lastUpdated:lastYTUpdated }, null, 2), 'utf8');

            // Loglar
            core.info(`Scanned: ${scanned}, MealAccepted: ${accepted}, YTAccepted: ${ytAccepted}, MealRows: ${rows.length}, YTRows: ${embedsRows.length}`);
            core.info(`lastUpdated(meal): ${lastUpdated || '-'}`);
            core.info(`lastUpdated(yt):   ${lastYTUpdated || '-'}`);

      - name: Commit data files  # >>> ADDED: iki dosyayı birden commit et
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "build: update data (normalized & embeds)"
          file_pattern: |
            data/normalized.json
            data/embeds.json
